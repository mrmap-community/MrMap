import json

from django.template.loader import render_to_string
from django.urls import reverse
from django.utils.html import format_html
from django.utils.translation import gettext_lazy as _
from django.contrib import messages
from django.contrib.auth.decorators import login_required
from django.db.models import Case, When
from django.http import HttpRequest, HttpResponseRedirect
from django.shortcuts import render, redirect, get_object_or_404
from MrMap import utils
from MrMap.decorator import check_permission, check_ownership
from MrMap.forms import MrMapConfirmForm
from MrMap.messages import EDITOR_ACCESS_RESTRICTED, \
    SECURITY_PROXY_WARNING_ONLY_FOR_ROOT
from MrMap.responses import DefaultContext, BackendAjaxResponse
from editor.forms import MetadataEditorForm, RemoveDatasetForm, RestoreMetadataForm, RestoreDatasetMetadata
from editor.settings import WMS_SECURED_OPERATIONS, WFS_SECURED_OPERATIONS
from editor.wizards import DATASET_WIZARD_FORMS, DatasetWizard
from service.helper.enums import OGCServiceEnum, MetadataEnum
from service.models import RequestOperation, SecuredOperation, Metadata, MetadataRelation
from service.tasks import async_process_secure_operations_form
from structure.models import Permission, MrMapGroup
from users.helper import user_helper
from editor.helper import editor_helper


@login_required
@check_permission(Permission(can_remove_dataset_metadata=True))
@check_ownership(Metadata, 'metadata_id')
def remove_dataset(request: HttpRequest, metadata_id: int, ):
    """ The remove view for dataset metadata

    Args:
        request: The incoming request
        metadata_id: The metadata id
    Returns:
        A rendered view
    """
    metadata = get_object_or_404(Metadata, id=metadata_id)
    if metadata.metadata_type.type != 'dataset':
        messages.success(request, message=_("You can't delete metadata record"))
        return HttpResponseRedirect(reverse(request.GET.get('current-view', 'home'), ), status=303)

    relations = MetadataRelation.objects.filter(metadata_to=metadata)
    is_mr_map_origin = True
    for relation in relations:
        if relation.origin.name != "MrMap":
            is_mr_map_origin = False
            break
    if is_mr_map_origin is not True:
        messages.success(request, message=_("You can't delete autogenerated datasets"))
        return HttpResponseRedirect(reverse(request.GET.get('current-view', 'home'), ), status=303)

    form = RemoveDatasetForm(data=request.POST or None,
                             request=request,
                             reverse_lookup='editor:remove-dataset-metadata',
                             reverse_args=[metadata_id, ],
                             # ToDo: after refactoring of all forms is done, show_modal can be removed
                             show_modal=True,
                             is_confirmed_label=_("Do you really want to delete this dataset?"),
                             instance=metadata)
    return form.process_request(valid_func=form.process_remove_dataset)


@login_required
@check_permission(Permission(can_add_dataset_metadata=True))
def add_new_dataset_wizard(request: HttpRequest, ):
    return DatasetWizard.as_view(form_list=DATASET_WIZARD_FORMS,
                                 ignore_uncomitted_forms=True,
                                 current_view=request.GET.get('current-view'),
                                 title=_(format_html('<b>Add New Dataset</b>')),
                                 id_wizard='add_new_dataset_wizard',
                                 )(request=request)


@login_required
@check_permission(Permission(can_edit_dataset_metadata=True))
@check_ownership(Metadata, 'metadata_id')
def edit_dataset_wizard(request, metadata_id: int):
    metadata = get_object_or_404(Metadata, id=metadata_id)
    return DatasetWizard.as_view(form_list=DATASET_WIZARD_FORMS,
                                 ignore_uncomitted_forms=True,
                                 current_view=request.GET.get('current-view'),
                                 current_view_arg=request.GET.get('current-view-arg', None),
                                 instance_id=metadata_id,
                                 title=_(format_html(f'<b>Edit</b> <i>{metadata.title}</i> <b>Dataset</b>')),
                                 id_wizard=f'edit_{metadata.id}_dataset_wizard',
                                 )(request=request)


@login_required
@check_permission(Permission(can_edit_metadata_service=True))
@check_ownership(Metadata, 'metadata_id')
def edit(request: HttpRequest, metadata_id: int,):
    """ The edit view for metadata

    Provides editing functions for all elements which are described by Metadata objects

    Args:
        request: The incoming request
        metadata_id: The metadata id
    Returns:
        A rendered view
    """
    metadata = get_object_or_404(Metadata, id=metadata_id)
    if metadata.metadata_type.type == 'dataset':
        return HttpResponseRedirect(reverse("editor:edit-dataset-metadata", args=(metadata_id,)), status=303)

    form = MetadataEditorForm(data=request.POST or None,
                              instance=metadata,
                              request=request,
                              reverse_lookup='editor:edit',
                              reverse_args=[metadata_id, ],
                              # ToDo: after refactoring of all forms is done, show_modal can be removed
                              show_modal=True,
                              has_autocomplete_fields=True,
                              form_title=_(f"Edit metadata <strong>{metadata.title}</strong>")
                              )
    return form.process_request(valid_func=form.process_edit_metadata)


@login_required
@check_permission(Permission(can_edit_metadata_service=True))
@check_ownership(Metadata, 'id')
def edit_access(request: HttpRequest, id: int):
    """ The edit view for the operations access

    Provides a form to set the access permissions for a metadata-related object.
    Processes the form input afterwards

    Args:
        request (HttpRequest): The incoming request
        id (int): The metadata id
    Returns:
         A rendered view
    """
    user = user_helper.get_user(request)

    md = Metadata.objects.get(id=id)
    template = "views/editor_edit_access_index.html"
    post_params = request.POST

    if request.method == "POST":
        # process form input using async tasks
        try:
            async_process_secure_operations_form.delay(post_params, md.id)
        except Exception as e:
            messages.error(request, message=e)
            return redirect("editor:edit_access", md.id)
        messages.success(request, EDITOR_ACCESS_RESTRICTED.format(md.title))
        md.save()
        if md.is_metadata_type(MetadataEnum.FEATURETYPE):
            redirect_id = md.featuretype.parent_service.metadata.id
        else:
            if md.service.is_root:
                redirect_id = md.id
            else:
                redirect_id = md.service.parent_service.metadata.id
        return redirect("service:detail", redirect_id)

    else:
        # render form
        secured_operations = []
        if md.is_service_type(OGCServiceEnum.WMS):
            secured_operations = WMS_SECURED_OPERATIONS
        elif md.is_service_type(OGCServiceEnum.WFS):
            secured_operations = WFS_SECURED_OPERATIONS

        operations = RequestOperation.objects.filter(
            operation_name__in=secured_operations
        )
        sec_ops = SecuredOperation.objects.filter(
            secured_metadata=md
        )
        all_groups = MrMapGroup.objects.all().order_by(Case(When(name='Public', then=0)), 'name')
        tmp = editor_helper.prepare_secured_operations_groups(operations, sec_ops, all_groups, md)

        spatial_restrictable_operations = [
            "GetMap",  # WMS
            "GetFeature"  # WFS
        ]

        params = {
            "service_metadata": md,
            "has_ext_auth": md.has_external_authentication(),
            "operations": tmp,
            "spatial_restrictable_operations": spatial_restrictable_operations,
        }

    context = DefaultContext(request, params, user).get_context()
    return render(request, template, context)


@login_required
def access_geometry_form(request: HttpRequest, id: int):
    """ Renders the geometry form for the access editing

    Args:
        request (HttpRequest): The incoming request
        id (int): The id of the metadata object, which will be edited
    Returns:
         BackendAjaxResponse
    """

    user = user_helper.get_user(request)
    template = "views/access_geometry_form.html"

    GET_params = request.GET
    operation = GET_params.get("operation", None)
    group_id = GET_params.get("groupId", None)
    polygons = utils.resolve_none_string(GET_params.get("polygons", 'None'))

    if polygons is not None:
        polygons = json.loads(polygons)
        if not isinstance(polygons, list):
            polygons = [polygons]

    md = Metadata.objects.get(id=id)

    if not md.is_root():
        messages.info(request, message=SECURITY_PROXY_WARNING_ONLY_FOR_ROOT)
        return BackendAjaxResponse(html="", redirect=reverse('edit_access', args=(md.id,))).get_response()

    service_bounding_geometry = md.find_max_bounding_box()

    params = {
        "action_url": reverse('editor:access_geometry_form', args=(md.id,)),
        "bbox": service_bounding_geometry,
        "group_id": group_id,
        "operation": operation,
        "polygons": polygons,
    }
    context = DefaultContext(request, params, user).get_context()
    html = render_to_string(template_name=template, request=request, context=context)
    return BackendAjaxResponse(html=html).get_response()


@login_required
@check_permission(Permission(can_edit_metadata_service=True))
@check_ownership(Metadata, 'metadata_id')
def restore(request: HttpRequest, metadata_id: int, ):
    """ Drops custom metadata and load original metadata from capabilities and ISO metadata

    Args,
        request: The incoming request
        id: The metadata id
    Returns:
         Redirects back to edit view
    """
    metadata = Metadata.objects.get(id=metadata_id)

    form = RestoreMetadataForm(data=request.POST or None,
                               request=request,
                               reverse_lookup='editor:restore',
                               reverse_args=[metadata_id, ],
                               # ToDo: after refactoring of all forms is done, show_modal can be removed
                               show_modal=True,
                               is_confirmed_label=_("Do you really want to restore this metadata?"),
                               form_title=_(f"Restore metadata <strong>{metadata.title}</strong>"),
                               instance=metadata)
    return form.process_request(valid_func=form.process_restore_metadata)


@login_required
@check_permission(Permission(can_edit_metadata_service=True))
@check_ownership(Metadata, 'metadata_id')
def restore_dataset_metadata(request: HttpRequest, metadata_id: int, ):
    """ Drops custom metadata and load original metadata from capabilities and ISO metadata

    Args,
        request: The incoming request
        id: The metadata id
    Returns:
         Redirects back to edit view
    """
    metadata = get_object_or_404(Metadata, id=metadata_id)

    form = RestoreDatasetMetadata(data=request.POST or None,
                                  request=request,
                                  reverse_lookup='editor:restore-dataset-metadata',
                                  reverse_args=[metadata_id, ],
                                  # ToDo: after refactoring of all forms is done, show_modal can be removed
                                  show_modal=True,
                                  is_confirmed_label=_("Do you really want to restore this dataset?"),
                                  form_title=_(f"Restore dataset metadata <strong>{metadata.title}</strong>"),
                                  instance=metadata)
    return form.process_request(valid_func=form.process_restore_dataset_metadata)
