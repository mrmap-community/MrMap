{% load i18n static %}

<link rel="stylesheet" href="{% static 'editor/css/leaflet-geoman.css' %}" />
<script src="{% static 'editor/js/leaflet-geoman.min.js' %}"></script>

<style>

.field-label, .field{
    font-size: 1.2em;
}

.field input, .field textarea, .field select{
    color: gray;
    background-color: white;
    border: 1px solid gray;
    border-radius: 0.25rem;
    padding: 0.375rem 0.75rem;
}

.field input:focus{
    -webkit-box-shadow: 0 0 10px var(--primary-color);
    -moz-box-shadow: 0 0 10px var(--primary-color);
    box-shadow: 0 0 10px var(--primary-color);
}

.form-submit-area{
    display: flex;
    justify-content: space-between;
    padding: 20px 0;
}
.modal-content{
    max-height: 75vh;
    overflow-y: auto;
}

.field{
    position: relative;
}

article{
    padding: 10px 0 10px 0;
}

</style>

{% block body %}
<div class="modal-dialog">
    <div class="modal-close" title="{% trans 'Close' %}">
        x
    </div>
    <div class="modal-content">
        <article>
            {{ article }}
        </article>
        <hr>
        <div id="map" class="map-view">
        </div>
        <script>
               var map = L.map('map', {
                   center: [{{ bbox.centroid.y }}, {{ bbox.centroid.x }}],
                   zoom: {{ bbox.area }},
                   layers: [
                       new L.TileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                           attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                       })
                   ],
               }).fitBounds(
                   [
                       [{{ bbox.boundary.extent.1 }}, {{ bbox.boundary.extent.0 }}],
                       [{{ bbox.boundary.extent.3 }}, {{ bbox.boundary.extent.2 }}],
                   ]
                   );

                // set which controls should be available in the toolbar
                map.pm.addControls({
                  position: 'topright',
                  drawCircle: false,
                  drawCircleMarker: false,
                  drawPolyline: false,
                  drawRectangle: true,
                  drawMarker: false,
                  removalMode: true,
                  cutPolygon: false,
                });

                // add pre-existing polygons
                {% for poly  in polygons %}
                    tmpLayer = L.geoJSON({{ poly|safe }}, {style: {fillColor: 'red', color: 'red'}}).addTo(map);

                    // write layer directly back to session
                    layerId = tmpLayer._leaflet_id;

                    // leaflet creates a FeatureCollection for each Feature, we need to get rid of the wrapping object!
                    var layerGeoJson = JSON.stringify(tmpLayer.toGeoJSON());
                    layerGeoJson = JSON.stringify(JSON.parse(layerGeoJson).features[0]);

                    setSessionValue("polygon_" + layerId ,layerGeoJson);

                    // create listener for each layer, that writes the edited polygon back into the session storage
                    tmpLayer.on("pm:edit", function(e){
                        layerId = e.target._leaflet_id;
                        layerGeoJson = JSON.stringify(e.sourceTarget.toGeoJSON());

                        setSessionValue("polygon_" + layerId ,layerGeoJson);
                    });
                {% endfor %}

               // create a listener which is triggered when a new polygon is finished
               map.on('pm:create', function(e){
                    // get the lat lon
                    var layerId = e.layer._leaflet_id;
                    var layerGeoJson = JSON.stringify(e.layer.toGeoJSON());

                    setSessionValue("polygon_" + layerId ,layerGeoJson);

                    // create a listener which is triggered when the polygon is edited
                    e.layer.on('pm:edit', e => {
                        layerId = e.sourceTarget._leaflet_id;
                        layerGeoJson = JSON.stringify(e.sourceTarget.toGeoJSON());
                        setSessionValue("polygon_" + layerId ,layerGeoJson);
                    });

               });

               // create listener that removes the polygon from the session if the layer is removed
               map.on('pm:remove', function(e){
                    // there are Features and FeatureGroups
                    // Features are layers, that have just been created by the user
                    // FeatureGroups have been created by the user in the past and have been added to the map automatically
                    // To remove both clear, we need to handle them differently
                    var layer = null;
                    if(e.layer._eventParents != null){
                        // FeatureGroup
                        for(var item in e.layer._eventParents){
                            layer = item;
                        }
                        layer = e.layer._eventParents[layer];
                    }else{
                        // Feature
                        layer = e.layer;
                    }
                    layerId = layer._leaflet_id;
                    getSessionValue("polygon_" + layerId ,true);
               });

           </script>
        <div>
            <article>{% trans 'Import a GML3 or GeoJSON file' %}</article>
            <input class="shapefile-upload" type="file" title="{% trans 'Load shapefile' %}"/>
        </div>
        <form action="{{ action_url }}" method="post" >

            <input class="submit-button button" id="submit-text" type="submit" value="{% trans 'Save' %}"/>
        </form>
    </div>
</div>

<script>

    $(".shapefile-upload").change(function(){
        var elem = $(this)[0];
        var file = elem.files[0];
        var appType = file.type;

        var fileReader = new FileReader();
        fileReader.readAsText(file);

        // wait until fileReader finished reading
        fileReader.onload = function(e){
            content = e.target.result;

            if(appType == "application/geo+json"){
                var geoJsonContent = JSON.parse(content);

                // create GeoJsonLayer
                tmpLayer = L.geoJSON(geoJsonContent, {style: {fillColor: 'red', color: 'red'}});

                for(key in tmpLayer._layers){
                    var layer = tmpLayer._layers[key];
                    layer.addTo(map);

                    // write layer directly back to session
                    layerId = layer._leaflet_id;
                    var layerGeoJson = JSON.stringify(layer.toGeoJSON());
                    setSessionValue("polygon_" + layerId ,layerGeoJson);

                    // create listener for each layer, that writes the edited polygon back into the session storage
                    layer.on("pm:edit", function(e){
                        layerId = e.target._leaflet_id;
                        layerGeoJson = JSON.stringify(e.sourceTarget.toGeoJSON());
                        setSessionValue("polygon_" + layerId ,layerGeoJson);
                    });

                }

            }else if (appType == "application/gml+xml"){
                parser = new DOMParser();
                gmlDoc = parser.parseFromString(content, "text/xml");
                gmlDocPolygons = gmlDoc.getElementsByTagName("gml:Polygon");

                polygonsArray = []

                for(l = 0; l < gmlDocPolygons.length; l++){
                    poly = gmlDocPolygons[l];
                    points = poly.getElementsByTagName("gml:posList");

                    for(j = 0; j < points.length; j++){
                        var tmp = []
                        var point = points[j];
                        var p = point.innerHTML.split(" ");

                        for(i = 0; i < p.length; i+=2){
                            // point pairs
                            tmp.push([parseFloat(p[i+1]), parseFloat(p[i])]);
                        }
                        polygonsArray.push(tmp);
                    }
                }

                // create own layer for each polygon
                for(i = 0; i < polygonsArray.length; i++){
                    polygon = polygonsArray[i];
                    layer = L.polygon(polygon, {style: {fillColor: 'red', color: 'red'}}).addTo(map);

                    // write layer directly back to session
                    layerId = layer._leaflet_id;
                    var layerGeoJson = JSON.stringify(layer.toGeoJSON());
                    setSessionValue("polygon_" + layerId ,layerGeoJson);

                    // create listener for each layer, that writes the edited polygon back into the session storage
                    layer.on("pm:edit", function(e){
                        layerId = e.target._leaflet_id;
                        layerGeoJson = JSON.stringify(e.sourceTarget.toGeoJSON());
                        setSessionValue("polygon_" + layerId ,layerGeoJson);
                    });
                }

            }else{
                alert("Unsupported geometry file type detected : '" + appType + "'");
            }
        }

    });

    $(".modal-close, .close-button").click(function(){
        // remove session stored polygon data
        removeSessionKeysLike("polygon_");

        toggleOverlay("");
    });

    $(".submit-button").click(function(event){

        // get session stored polygon data
        values = findSessionKeysLike("polygon_");

        // write current polygons to session
        var polygons = [];
        for(i = 0; i < values.length; i++){
            polygons.push(JSON.parse(getSessionValue(values[i], true)));
        }

        // find element where the polygons will be stored
        var operationGroupPolygonElement = $("input[data-operation={{ operation }}][data-group={{ group_id }}]")

        // show 'listable' element, which indicates that polygons have been set
        if(polygons.length > 0){
            operationGroupPolygonElement.siblings(".listable").show();
            if(!operationGroupPolygonElement.is(":checked")){
                operationGroupPolygonElement.click();
            }
            // set data to element
            operationGroupPolygonElement.attr("data-polygons", JSON.stringify(polygons));
        }else{
            operationGroupPolygonElement.removeAttr("data-polygons");
            operationGroupPolygonElement.siblings(".listable").hide();
        }
        toggleOverlay("");
    });

</script>

{% endblock %}