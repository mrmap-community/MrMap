# Generated by Django 5.0 on 2024-01-12 12:54

import django.contrib.gis.db.models.fields
import django.contrib.postgres.fields
import django.contrib.postgres.search
import registry.models.document
import uuid
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('registry', '0001_initial'),
    ]

    operations = [
        migrations.CreateModel(
            name='SearchableDatasetMetadataRecord',
            fields=[
                ('xml_backup_file', models.FileField(editable=False, help_text='the original xml as backup to restore the xml field.', upload_to=registry.models.document.xml_backup_file_path, verbose_name='xml backup')),
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('date_stamp', models.DateTimeField(auto_now_add=True, db_index=True, help_text='date that the metadata was created. If this is a metadata record which is parsed from remote iso metadata, the date stamp of the remote iso metadata will be used.', verbose_name='date stamp')),
                ('origin', models.CharField(choices=[('Capabilities', 'Capabilities'), ('Upload', 'Upload'), ('File System Import', 'File System Import'), ('Editor', 'Editor'), ('Catalogue', 'Catalogue')], editable=False, help_text='Where the metadata record comes from.', max_length=20, verbose_name='origin')),
                ('origin_url', models.URLField(blank=True, editable=False, help_text='the url of the document where the information of this metadata record comes from', max_length=4096, null=True, verbose_name='origin url')),
                ('is_broken', models.BooleanField(default=False, editable=False, help_text='TODO', verbose_name='is broken')),
                ('is_customized', models.BooleanField(default=False, editable=False, help_text='If the metadata record is customized, this flag is True', verbose_name='is customized')),
                ('insufficient_quality', models.TextField(blank=True, default='', help_text='TODO')),
                ('is_searchable', models.BooleanField(default=False, help_text='only searchable metadata will be returned from the search api', verbose_name='is searchable')),
                ('hits', models.IntegerField(default=0, editable=False, help_text='how many times this metadata was requested by a client', verbose_name='hits')),
                ('title', models.CharField(default='', max_length=1000)),
                ('abstract', models.TextField(default='')),
                ('file_identifier', models.CharField(max_length=1000)),
                ('code', models.CharField(default='', max_length=4096)),
                ('code_space', models.CharField(default='', max_length=4096)),
                ('resource_identifier', models.CharField(default='', max_length=4096)),
                ('keywords_list', django.contrib.postgres.fields.ArrayField(base_field=models.CharField(max_length=300), default=list, editable=False, size=None)),
                ('bounding_geometry', django.contrib.gis.db.models.fields.MultiPolygonField(blank=True, null=True, srid=4326)),
                ('search_vector', django.contrib.postgres.search.SearchVectorField()),
                ('hierarchy_level', models.CharField(default='', max_length=100)),
            ],
            options={
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='SearchableServiceMetadataRecord',
            fields=[
                ('xml_backup_file', models.FileField(editable=False, help_text='the original xml as backup to restore the xml field.', upload_to=registry.models.document.xml_backup_file_path, verbose_name='xml backup')),
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('date_stamp', models.DateTimeField(auto_now_add=True, db_index=True, help_text='date that the metadata was created. If this is a metadata record which is parsed from remote iso metadata, the date stamp of the remote iso metadata will be used.', verbose_name='date stamp')),
                ('origin', models.CharField(choices=[('Capabilities', 'Capabilities'), ('Upload', 'Upload'), ('File System Import', 'File System Import'), ('Editor', 'Editor'), ('Catalogue', 'Catalogue')], editable=False, help_text='Where the metadata record comes from.', max_length=20, verbose_name='origin')),
                ('origin_url', models.URLField(blank=True, editable=False, help_text='the url of the document where the information of this metadata record comes from', max_length=4096, null=True, verbose_name='origin url')),
                ('is_broken', models.BooleanField(default=False, editable=False, help_text='TODO', verbose_name='is broken')),
                ('is_customized', models.BooleanField(default=False, editable=False, help_text='If the metadata record is customized, this flag is True', verbose_name='is customized')),
                ('insufficient_quality', models.TextField(blank=True, default='', help_text='TODO')),
                ('is_searchable', models.BooleanField(default=False, help_text='only searchable metadata will be returned from the search api', verbose_name='is searchable')),
                ('hits', models.IntegerField(default=0, editable=False, help_text='how many times this metadata was requested by a client', verbose_name='hits')),
                ('title', models.CharField(default='', max_length=1000)),
                ('abstract', models.TextField(default='')),
                ('file_identifier', models.CharField(max_length=1000)),
                ('code', models.CharField(default='', max_length=4096)),
                ('code_space', models.CharField(default='', max_length=4096)),
                ('resource_identifier', models.CharField(default='', max_length=4096)),
                ('keywords_list', django.contrib.postgres.fields.ArrayField(base_field=models.CharField(max_length=300), default=list, editable=False, size=None)),
                ('bounding_geometry', django.contrib.gis.db.models.fields.MultiPolygonField(blank=True, null=True, srid=4326)),
                ('search_vector', django.contrib.postgres.search.SearchVectorField()),
                ('hierarchy_level', models.CharField(default='', max_length=100)),
            ],
            options={
                'managed': False,
            },
        ),
        migrations.AlterField(
            model_name='catalogueservice',
            name='keywords',
            field=models.ManyToManyField(blank=True, help_text='all keywords which are related to the content of this metadata.', related_name='%(class)s_metadata', related_query_name='%(class)s_metadata', to='registry.keyword', verbose_name='keywords'),
        ),
        migrations.AlterField(
            model_name='datasetmetadatarecord',
            name='keywords',
            field=models.ManyToManyField(blank=True, help_text='all keywords which are related to the content of this metadata.', related_name='%(class)s_metadata', related_query_name='%(class)s_metadata', to='registry.keyword', verbose_name='keywords'),
        ),
        migrations.AlterField(
            model_name='featuretype',
            name='keywords',
            field=models.ManyToManyField(blank=True, help_text='all keywords which are related to the content of this metadata.', related_name='%(class)s_metadata', related_query_name='%(class)s_metadata', to='registry.keyword', verbose_name='keywords'),
        ),
        migrations.AlterField(
            model_name='layer',
            name='keywords',
            field=models.ManyToManyField(blank=True, help_text='all keywords which are related to the content of this metadata.', related_name='%(class)s_metadata', related_query_name='%(class)s_metadata', to='registry.keyword', verbose_name='keywords'),
        ),
        migrations.AlterField(
            model_name='servicemetadatarecord',
            name='keywords',
            field=models.ManyToManyField(blank=True, help_text='all keywords which are related to the content of this metadata.', related_name='%(class)s_metadata', related_query_name='%(class)s_metadata', to='registry.keyword', verbose_name='keywords'),
        ),
        migrations.AlterField(
            model_name='webfeatureservice',
            name='keywords',
            field=models.ManyToManyField(blank=True, help_text='all keywords which are related to the content of this metadata.', related_name='%(class)s_metadata', related_query_name='%(class)s_metadata', to='registry.keyword', verbose_name='keywords'),
        ),
        migrations.AlterField(
            model_name='webmapservice',
            name='keywords',
            field=models.ManyToManyField(blank=True, help_text='all keywords which are related to the content of this metadata.', related_name='%(class)s_metadata', related_query_name='%(class)s_metadata', to='registry.keyword', verbose_name='keywords'),
        ),
    ]
