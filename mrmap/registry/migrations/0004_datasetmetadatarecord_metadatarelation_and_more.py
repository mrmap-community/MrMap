# Generated by Django 4.1.11 on 2023-10-26 11:45

import django.contrib.gis.db.models.fields
from django.db import migrations, models
import django.db.models.deletion
import django.db.models.manager
import registry.models.document
import uuid


class Migration(migrations.Migration):

    dependencies = [
        ('registry', '0003_alter_catalogueservice_origin_and_more'),
    ]

    operations = [
        migrations.CreateModel(
            name='DatasetMetadataRecord',
            fields=[
                ('xml_backup_file', models.FileField(editable=False, help_text='the original xml as backup to restore the xml field.', upload_to=registry.models.document.xml_backup_file_path, verbose_name='xml backup')),
                ('access_constraints', models.TextField(blank=True, help_text='access constraints for the given resource.', null=True, verbose_name='access constraints')),
                ('fees', models.TextField(blank=True, help_text='Costs and of terms of use for the given resource.', null=True, verbose_name='fees')),
                ('use_limitation', models.TextField(blank=True, null=True)),
                ('license_source_note', models.TextField(blank=True, null=True)),
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('date_stamp', models.DateTimeField(auto_now_add=True, db_index=True, help_text='date that the metadata was created. If this is a metadata record which is parsed from remote iso metadata, the date stamp of the remote iso metadata will be used.', verbose_name='date stamp')),
                ('file_identifier', models.CharField(db_index=True, default=uuid.uuid4, editable=False, help_text='the parsed file identifier from the iso metadata xml (gmd:fileIdentifier) OR for example if it is a layer/featuretypethe uuid of the described layer/featuretype shall be used to identify the generated iso metadata xml.', max_length=1000, null=True, verbose_name='file identifier')),
                ('origin', models.CharField(choices=[('capabilities', 'Capabilities'), ('iso metadata', 'Iso Metadata')], editable=False, help_text='Where the metadata record comes from.', max_length=20, verbose_name='origin')),
                ('origin_url', models.URLField(blank=True, editable=False, help_text='the url of the document where the information of this metadata record comes from', max_length=4096, null=True, verbose_name='origin url')),
                ('title', models.CharField(help_text='a short descriptive title for this metadata', max_length=1000, verbose_name='title')),
                ('abstract', models.TextField(help_text='brief summary of the content of this metadata.', null=True, verbose_name='abstract')),
                ('is_broken', models.BooleanField(default=False, editable=False, help_text='TODO', verbose_name='is broken')),
                ('is_customized', models.BooleanField(default=False, editable=False, help_text='If the metadata record is customized, this flag is True', verbose_name='is customized')),
                ('insufficient_quality', models.TextField(blank=True, help_text='TODO', null=True)),
                ('is_searchable', models.BooleanField(default=False, help_text='only searchable metadata will be returned from the search api', verbose_name='is searchable')),
                ('hits', models.IntegerField(default=0, editable=False, help_text='how many times this metadata was requested by a client', verbose_name='hits')),
                ('spatial_res_type', models.CharField(choices=[('groundDistance', 'groundDistance'), ('scaleDenominator', 'scaleDenominator')], default='', help_text='Ground resolution in meter or the equivalent scale.', max_length=20, verbose_name='resolution type')),
                ('spatial_res_value', models.FloatField(blank=True, help_text='The value depending on the selected resolution type.', null=True, verbose_name='resolution value')),
                ('format', models.CharField(blank=True, choices=[('Database', 'Database'), ('Esri shape', 'Esri Shape'), ('CSV', 'Csv'), ('GML', 'Gml'), ('GeoTIFF', 'Geotiff')], default='', help_text='The format in which the described dataset is stored.', max_length=20, verbose_name='format')),
                ('charset', models.CharField(blank=True, choices=[('utf8', 'Utf8')], default='', help_text='The charset which is used by the stored data.', max_length=10, verbose_name='charset')),
                ('inspire_top_consistence', models.BooleanField(default=False, help_text='Flag to signal if the described data has a topologically consistence.')),
                ('preview_image', models.ImageField(blank=True, null=True, upload_to='')),
                ('lineage_statement', models.TextField(blank=True, default='')),
                ('update_frequency_code', models.CharField(blank=True, choices=[('annually', 'annually'), ('asNeeded', 'asNeeded'), ('biannually', 'biannually'), ('irregular', 'irregular'), ('notPlanned', 'notPlanned'), ('unknown', 'unknown')], default='', max_length=20)),
                ('bounding_geometry', django.contrib.gis.db.models.fields.MultiPolygonField(blank=True, null=True, srid=4326)),
                ('dataset_id', models.CharField(default='', help_text='identifier of the remote data', max_length=4096)),
                ('dataset_id_code_space', models.CharField(blank=True, default='', help_text='code space for the given identifier', max_length=4096)),
                ('inspire_interoperability', models.BooleanField(default=False, help_text='flag to signal if this ')),
                ('dataset_contact', models.ForeignKey(help_text='this is the contact which provides this dataset.', on_delete=django.db.models.deletion.RESTRICT, related_name='dataset_contact_metadata', related_query_name='dataset_contact_metadata', to='registry.metadatacontact', verbose_name='contact')),
                ('harvested_through', models.ManyToManyField(blank=True, editable=False, help_text='all services from which this dataset was harvested.', related_name='%(app_label)s_%(class)s_metadata_records', related_query_name='%(app_label)s_%(class)s_metadata_record', to='registry.catalogueservice', verbose_name='services')),
                ('keywords', models.ManyToManyField(help_text='all keywords which are related to the content of this metadata.', related_name='%(class)s_metadata', related_query_name='%(class)s_metadata', to='registry.keyword', verbose_name='keywords')),
                ('licence', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.RESTRICT, to='registry.licence')),
                ('metadata_contact', models.ForeignKey(help_text='this is the contact which is responsible for the metadata information of the dataset.', on_delete=django.db.models.deletion.RESTRICT, related_name='metadata_contact_metadata', related_query_name='metadata_contact_metadata', to='registry.metadatacontact', verbose_name='contact')),
                ('reference_systems', models.ManyToManyField(blank=True, related_name='dataset_metadata', related_query_name='dataset_metadata', to='registry.referencesystem', verbose_name='reference systems')),
            ],
            options={
                'verbose_name': 'dataset metadata',
                'verbose_name_plural': 'dataset metadata',
            },
        ),
        migrations.CreateModel(
            name='MetadataRelation',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('is_internal', models.BooleanField(default=False, help_text='true means that this relation is created by a user and the dataset is maybe not linked in a capabilities document for example.', verbose_name='internal relation?')),
                ('origin', models.CharField(choices=[('Capabilities', 'Capabilities'), ('Upload', 'Upload'), ('Editor', 'Editor'), ('Catalogue', 'Catalogue')], help_text='determines where this relation was found or it is added by a user.', max_length=20, verbose_name='origin')),
                ('csw', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, related_name='metadata_relations', related_query_name='metadata_relation', to='registry.catalogueservice')),
                ('dataset_metadata', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, related_name='resource_relations', related_query_name='resource_relation', to='registry.datasetmetadatarecord')),
                ('feature_type', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, related_name='metadata_relations', related_query_name='metadata_relation', to='registry.featuretype')),
                ('layer', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, related_name='metadata_relations', related_query_name='metadata_relation', to='registry.layer')),
            ],
        ),
        migrations.CreateModel(
            name='ServiceMetadataRecord',
            fields=[
                ('xml_backup_file', models.FileField(editable=False, help_text='the original xml as backup to restore the xml field.', upload_to=registry.models.document.xml_backup_file_path, verbose_name='xml backup')),
                ('access_constraints', models.TextField(blank=True, help_text='access constraints for the given resource.', null=True, verbose_name='access constraints')),
                ('fees', models.TextField(blank=True, help_text='Costs and of terms of use for the given resource.', null=True, verbose_name='fees')),
                ('use_limitation', models.TextField(blank=True, null=True)),
                ('license_source_note', models.TextField(blank=True, null=True)),
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('date_stamp', models.DateTimeField(auto_now_add=True, db_index=True, help_text='date that the metadata was created. If this is a metadata record which is parsed from remote iso metadata, the date stamp of the remote iso metadata will be used.', verbose_name='date stamp')),
                ('file_identifier', models.CharField(db_index=True, default=uuid.uuid4, editable=False, help_text='the parsed file identifier from the iso metadata xml (gmd:fileIdentifier) OR for example if it is a layer/featuretypethe uuid of the described layer/featuretype shall be used to identify the generated iso metadata xml.', max_length=1000, null=True, verbose_name='file identifier')),
                ('origin', models.CharField(choices=[('capabilities', 'Capabilities'), ('iso metadata', 'Iso Metadata')], editable=False, help_text='Where the metadata record comes from.', max_length=20, verbose_name='origin')),
                ('origin_url', models.URLField(blank=True, editable=False, help_text='the url of the document where the information of this metadata record comes from', max_length=4096, null=True, verbose_name='origin url')),
                ('title', models.CharField(help_text='a short descriptive title for this metadata', max_length=1000, verbose_name='title')),
                ('abstract', models.TextField(help_text='brief summary of the content of this metadata.', null=True, verbose_name='abstract')),
                ('is_broken', models.BooleanField(default=False, editable=False, help_text='TODO', verbose_name='is broken')),
                ('is_customized', models.BooleanField(default=False, editable=False, help_text='If the metadata record is customized, this flag is True', verbose_name='is customized')),
                ('insufficient_quality', models.TextField(blank=True, help_text='TODO', null=True)),
                ('is_searchable', models.BooleanField(default=False, help_text='only searchable metadata will be returned from the search api', verbose_name='is searchable')),
                ('hits', models.IntegerField(default=0, editable=False, help_text='how many times this metadata was requested by a client', verbose_name='hits')),
                ('harvested_through', models.ManyToManyField(blank=True, editable=False, help_text='all services from which this dataset was harvested.', related_name='%(app_label)s_%(class)s_metadata_records', related_query_name='%(app_label)s_%(class)s_metadata_record', to='registry.catalogueservice', verbose_name='services')),
                ('keywords', models.ManyToManyField(help_text='all keywords which are related to the content of this metadata.', related_name='%(class)s_metadata', related_query_name='%(class)s_metadata', to='registry.keyword', verbose_name='keywords')),
                ('licence', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.RESTRICT, to='registry.licence')),
                ('self_pointing_feature_types', models.ManyToManyField(blank=True, editable=False, help_text='all feature types which are linking to this dataset metadata in there capabilities.', related_name='%(app_label)s_%(class)s_metadata_records', related_query_name='%(app_label)s_%(class)s_metadata_record', through='registry.MetadataRelation', to='registry.featuretype', verbose_name='feature types')),
                ('self_pointing_layers', models.ManyToManyField(blank=True, editable=False, help_text='all layers which are linking to this dataset metadata in there capabilities.', related_name='%(app_label)s_%(class)s_metadata_records', related_query_name='%(app_label)s_%(class)s_metadata_record', through='registry.MetadataRelation', to='registry.layer', verbose_name='layers')),
                ('self_pointing_wfs', models.ManyToManyField(blank=True, editable=False, help_text='all csw which are linking to this service metadata in there capabilities.', related_name='%(app_label)s_%(class)s_service_metadata', related_query_name='%(app_label)s_%(class)s_service_metadata', through='registry.MetadataRelation', to='registry.catalogueservice', verbose_name='catalogue services')),
                ('self_pointing_wms', models.ManyToManyField(blank=True, editable=False, help_text='all wms which are linking to this service metadata in there capabilities.', related_name='%(app_label)s_%(class)s_service_metadata', related_query_name='%(app_label)s_%(class)s_service_metadata', through='registry.MetadataRelation', to='registry.webmapservice', verbose_name='web map services')),
            ],
            options={
                'abstract': False,
            },
            managers=[
                ('iso_metadata', django.db.models.manager.Manager()),
            ],
        ),
        migrations.RemoveField(
            model_name='datasetmetadata',
            name='dataset_contact',
        ),
        migrations.RemoveField(
            model_name='datasetmetadata',
            name='keywords',
        ),
        migrations.RemoveField(
            model_name='datasetmetadata',
            name='licence',
        ),
        migrations.RemoveField(
            model_name='datasetmetadata',
            name='metadata_contact',
        ),
        migrations.RemoveField(
            model_name='datasetmetadata',
            name='reference_systems',
        ),
        migrations.RemoveField(
            model_name='datasetmetadata',
            name='self_pointing_catalogue_service',
        ),
        migrations.RemoveField(
            model_name='datasetmetadata',
            name='self_pointing_feature_types',
        ),
        migrations.RemoveField(
            model_name='datasetmetadata',
            name='self_pointing_layers',
        ),
        migrations.RemoveField(
            model_name='harvestingjob',
            name='existing_records',
        ),
        migrations.RemoveField(
            model_name='harvestingjob',
            name='new_records',
        ),
        migrations.RemoveField(
            model_name='harvestingjob',
            name='record_type',
        ),
        migrations.RemoveField(
            model_name='harvestingjob',
            name='updated_records',
        ),
        migrations.AddField(
            model_name='harvestingjob',
            name='harvest_datasets',
            field=models.BooleanField(default=True),
        ),
        migrations.AddField(
            model_name='harvestingjob',
            name='harvest_services',
            field=models.BooleanField(default=True),
        ),
        migrations.DeleteModel(
            name='DatasetMetadataRelation',
        ),
        migrations.AddField(
            model_name='metadatarelation',
            name='service_metadata',
            field=models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, related_name='resource_relations', related_query_name='resource_relation', to='registry.servicemetadatarecord'),
        ),
        migrations.AddField(
            model_name='metadatarelation',
            name='wfs',
            field=models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, related_name='metadata_relations', related_query_name='metadata_relation', to='registry.webfeatureservice'),
        ),
        migrations.AddField(
            model_name='metadatarelation',
            name='wms',
            field=models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, related_name='metadata_relations', related_query_name='metadata_relation', to='registry.webmapservice'),
        ),
        migrations.AddField(
            model_name='datasetmetadatarecord',
            name='self_pointing_feature_types',
            field=models.ManyToManyField(blank=True, editable=False, help_text='all feature types which are linking to this dataset metadata in there capabilities.', related_name='%(app_label)s_%(class)s_metadata_records', related_query_name='%(app_label)s_%(class)s_metadata_record', through='registry.MetadataRelation', to='registry.featuretype', verbose_name='feature types'),
        ),
        migrations.AddField(
            model_name='datasetmetadatarecord',
            name='self_pointing_layers',
            field=models.ManyToManyField(blank=True, editable=False, help_text='all layers which are linking to this dataset metadata in there capabilities.', related_name='%(app_label)s_%(class)s_metadata_records', related_query_name='%(app_label)s_%(class)s_metadata_record', through='registry.MetadataRelation', to='registry.layer', verbose_name='layers'),
        ),
        migrations.AddField(
            model_name='harvestingjob',
            name='existing_dataset_records',
            field=models.ManyToManyField(editable=False, related_name='ignored_by', to='registry.datasetmetadatarecord'),
        ),
        migrations.AddField(
            model_name='harvestingjob',
            name='existing_service_records',
            field=models.ManyToManyField(editable=False, related_name='ignored_by', to='registry.servicemetadatarecord'),
        ),
        migrations.AddField(
            model_name='harvestingjob',
            name='new_dataset_records',
            field=models.ManyToManyField(editable=False, related_name='harvested_by', to='registry.datasetmetadatarecord'),
        ),
        migrations.AddField(
            model_name='harvestingjob',
            name='new_service_records',
            field=models.ManyToManyField(editable=False, related_name='harvested_by', to='registry.servicemetadatarecord'),
        ),
        migrations.AddField(
            model_name='harvestingjob',
            name='updated_dataset_records',
            field=models.ManyToManyField(editable=False, related_name='updated_by', to='registry.datasetmetadatarecord'),
        ),
        migrations.AddField(
            model_name='harvestingjob',
            name='updated_service_records',
            field=models.ManyToManyField(editable=False, related_name='updated_by', to='registry.servicemetadatarecord'),
        ),
        migrations.AlterField(
            model_name='datasetmetadataconformitycheckrun',
            name='dataset_metadata',
            field=models.ForeignKey(blank=True, help_text='the dataset metadata targeted by this check', null=True, on_delete=django.db.models.deletion.CASCADE, to='registry.datasetmetadatarecord', verbose_name='dataset metadata'),
        ),
        migrations.AlterField(
            model_name='dimension',
            name='dataset_metadata',
            field=models.ForeignKey(blank=True, help_text='the related dataset metadata of this dimension entity', null=True, on_delete=django.db.models.deletion.CASCADE, related_name='dataset_metadata_dimensions', related_query_name='dataset_metadata_dimension', to='registry.datasetmetadatarecord', verbose_name='dataset metadata'),
        ),
        migrations.AlterField(
            model_name='historicalmapcontextlayer',
            name='dataset_metadata',
            field=models.ForeignKey(blank=True, db_constraint=False, help_text='You can use this field to pre filter possible Layer selection.', null=True, on_delete=django.db.models.deletion.DO_NOTHING, related_name='+', to='registry.datasetmetadatarecord', verbose_name='Dataset Metadata'),
        ),
        migrations.AlterField(
            model_name='mapcontextlayer',
            name='dataset_metadata',
            field=models.ForeignKey(blank=True, help_text='You can use this field to pre filter possible Layer selection.', null=True, on_delete=django.db.models.deletion.PROTECT, to='registry.datasetmetadatarecord', verbose_name='Dataset Metadata'),
        ),
        migrations.DeleteModel(
            name='DatasetMetadata',
        ),
        migrations.AddConstraint(
            model_name='metadatarelation',
            constraint=models.CheckConstraint(check=models.Q(models.Q(('csw__isnull', True), ('dataset_metadata__isnull', True), ('feature_type__isnull', True), ('layer__isnull', False), ('service_metadata__isnull', False), ('wfs__isnull', True), ('wms__isnull', True)), models.Q(('csw__isnull', True), ('dataset_metadata__isnull', False), ('feature_type__isnull', True), ('layer__isnull', False), ('service_metadata__isnull', True), ('wfs__isnull', True), ('wms__isnull', True)), models.Q(('csw__isnull', True), ('dataset_metadata__isnull', True), ('feature_type__isnull', True), ('layer__isnull', False), ('service_metadata__isnull', False), ('wfs__isnull', True), ('wms__isnull', True)), models.Q(('csw__isnull', True), ('dataset_metadata__isnull', True), ('feature_type__isnull', False), ('layer__isnull', True), ('service_metadata__isnull', True), ('wfs__isnull', True), ('wms__isnull', True)), models.Q(('csw__isnull', True), ('dataset_metadata__isnull', False), ('feature_type__isnull', False), ('layer__isnull', True), ('service_metadata__isnull', True), ('wfs__isnull', True), ('wms__isnull', True)), models.Q(('csw__isnull', True), ('dataset_metadata__isnull', True), ('feature_type__isnull', False), ('layer__isnull', True), ('service_metadata__isnull', False), ('wfs__isnull', True), ('wms__isnull', True)), models.Q(('csw__isnull', False), ('dataset_metadata__isnull', True), ('feature_type__isnull', True), ('layer__isnull', True), ('service_metadata__isnull', True), ('wfs__isnull', True), ('wms__isnull', True)), models.Q(('csw__isnull', False), ('dataset_metadata__isnull', True), ('feature_type__isnull', True), ('layer__isnull', True), ('service_metadata__isnull', False), ('wfs__isnull', True), ('wms__isnull', True)), models.Q(('csw__isnull', True), ('dataset_metadata__isnull', True), ('feature_type__isnull', True), ('layer__isnull', True), ('service_metadata__isnull', True), ('wfs__isnull', True), ('wms__isnull', False)), models.Q(('csw__isnull', True), ('dataset_metadata__isnull', True), ('feature_type__isnull', True), ('layer__isnull', True), ('service_metadata__isnull', False), ('wfs__isnull', True), ('wms__isnull', False)), models.Q(('csw__isnull', True), ('dataset_metadata__isnull', True), ('feature_type__isnull', True), ('layer__isnull', True), ('service_metadata__isnull', True), ('wfs__isnull', False), ('wms__isnull', True)), models.Q(('csw__isnull', True), ('dataset_metadata__isnull', True), ('feature_type__isnull', True), ('layer__isnull', True), ('service_metadata__isnull', False), ('wfs__isnull', False), ('wms__isnull', True)), models.Q(('csw__isnull', True), ('dataset_metadata__isnull', False), ('feature_type__isnull', True), ('layer__isnull', True), ('service_metadata__isnull', True), ('wfs__isnull', True), ('wms__isnull', True)), models.Q(('csw__isnull', True), ('dataset_metadata__isnull', True), ('feature_type__isnull', True), ('layer__isnull', True), ('service_metadata__isnull', False), ('wfs__isnull', True), ('wms__isnull', True)), _connector='OR'), name='registry_metadatarelation_one_related_object_selected'),
        ),
        migrations.AddIndex(
            model_name='datasetmetadatarecord',
            index=models.Index(fields=['dataset_id', 'dataset_id_code_space'], name='registry_da_dataset_309eb0_idx'),
        ),
        migrations.AddConstraint(
            model_name='datasetmetadatarecord',
            constraint=models.UniqueConstraint(condition=models.Q(('dataset_id', ''), ('dataset_id_code_space', ''), _negated=True), fields=('dataset_id', 'dataset_id_code_space'), name='registry_datasetmetadatarecord_unique_together_dataset_id_dataset_id_code_space'),
        ),
    ]
